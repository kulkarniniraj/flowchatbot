# AUTOGENERATED! DO NOT EDIT! File to edit: multiprocess-bot.ipynb (unless otherwise specified).

__all__ = ['debug_print', 'get_chained_data', 'set_chained_data', 'tryint', 'CHAT_RET', 'Pipe', 'Segment',
           'ValidatedSegment', 'MultiChoiceSegment', 'ComputeSegment', 'Composite', 'LoopComposite', 'TextAdapter',
           'Splitter', 'SkipSplitter']

# Cell
import redis
import enum
import json
import re

# Cell
def debug_print(*args):
    if ('DEBUG' in globals()) and (DEBUG == 1):
        print(f'DEBUG: {args}')
    else:
        pass

# Cell
def get_chained_data(data, *keys):
    """
    Gets data from dict hierarchy with given keys
    (none if any link is missing)
    """
    d = data
    for key in keys:
        if key not in d:
            return None
        d = d[key]
    return d

def set_chained_data(data, *keys, val=0):
    """
    Sets data to dict hierarchy and creating links where necessary
    """
    d = data
    for key in keys[:-1]:
        if key not in d:
            d[key] = {}
        d = d[key]
    d[keys[-1]] = val


# Cell
def tryint(x):
    """
    Check if input can be parsed as int, return -1 otherwise
    """
    try:
        return int(x)
    except:
        return -1


# Cell
class CHAT_RET(enum.Enum):
    """
    Movement values from chat segment.
    If return stay, bot should reask this question
    If next, bot should move to next in link
    """
    STAY = 0
    NEXT = 1

# Cell
class Pipe:
    """
    Base class for all flow element classes
    Sets up key, None as next link and callbacks for question and answer call
    """
    def __init__(self, on_question=None, on_answer=None):
        self.key = ''
        self.next = None
        self.on_question = on_question
        self.on_answer = on_answer

    def __repr__(self):
        return f'{type(self)}: {self.key}'

    def question(self):
        pass

    def answer(self, resp):
        pass

# Cell
class Segment(Pipe):
    """
    Basic segment unit, asks one question and gives one answer
    Stores response as it is in 'data' field
    """
    def __init__(self, key, q, a, **kwargs):
        super().__init__(**kwargs)
        self.q = q
        self.a = a
        self.key = key

    def question(self, data):
        if self.on_question:
            self.on_question(data)
        return {'txt': self.q}

    def answer(self, resp, data):
        data['data'] = resp
        if self.on_answer:
            self.on_answer(data)
        return CHAT_RET.NEXT, {'txt': self.a}


# Cell
class ValidatedSegment(Segment):
    """
    Segment element with data validation facility
    Constructor takes validation function as arg.
    """
    def __init__(self, key, q, a, errmsg, valid_fn):
        """
        valid_fn is called with user response. If it returns true, data
        is stored and bot moves forward, otherwise bot stays and shows error message
        """
        super().__init__(key, q, a)
        self.err = errmsg
        self.valid_fn = valid_fn

    def answer(self, resp, data):
        if self.valid_fn(resp):
            return super().answer(resp, data)
        data['data'] = ''
        return CHAT_RET.STAY, {'txt': self.err}


# Cell
class MultiChoiceSegment(Segment):
    """
    Element for asking question with multi choice answers.
    Both response number and corresponding answer is stored in data
    """
    def __init__(self, key, q, resp_lst, ans, **kwargs):
        """
        resp_lst is list of choices to be given. Numbered from 1 to n
        """
        super().__init__(key, q, ans, **kwargs)
        self.resp_lst = resp_lst

    def question(self, data):
#         return {'txt': self.q + '\n' + '\n'.join([f'{i+1}. {q}' for (i,q) in enumerate(self.resp_lst)])}
        return {'txt': self.q, 'choices': self.resp_lst}

    def answer(self, resp, data):
        if 0 < tryint(resp) <= len(self.resp_lst):
            data['data'] = (tryint(resp) - 1, self.resp_lst[tryint(resp) - 1])
            return CHAT_RET.NEXT, {'txt': self.a}
        return CHAT_RET.STAY, {'txt': f'Please enter one of 1..{len(self.resp_lst)} as answer'}


# Cell
class ComputeSegment(Segment):
    """
    Segment to do computation. Data of parent elememnt is passed to answer function
    Should be inherited with overriden answer function to do actual computations
    """
    def answer(self, resp, data):
        """
        data of parent is passed
        """
        return super().answer(resp, data)

# Cell
class Composite(Pipe):
    """
    Composite element, can have any other element including composite as children.
    All children form linked list and traversed sequentially while this element
    will return STAY
    When end of linked list is reached, element returns NEXT
    """
    def __init__(self, key, *args):
        """
        args correspond to all children elements
        """
        super().__init__()
        for i in range(len(args) - 1):
            args[i].next = args[i+1]

        self.args = args
        self.key = key

        self.nodes = {}
        for a in args:
            self.nodes[a.key] = a

    def getpos(self, data):
        pos = get_chained_data(data, 'pos')
        if pos is None:
            pos = self.args[0].key
            set_chained_data(data, 'pos', val=pos)

        return self.nodes[pos]

    def setpos(self, data, pos):
        set_chained_data(data, 'pos', val=pos.key)

    def getdata(self, data, key):
        val = get_chained_data(data, key)
        if val is None:
            val = {}
            set_chained_data(data, key, val=val)
        return val

    def question(self, data):
        cur = self.getpos(data)
        debug_print(f'composite question current {cur.key} data {data}')
        curdata = self.getdata(data, cur.key)

        if isinstance(cur, Splitter):
            q = cur.question(data)
        else:
            q = cur.question(curdata)

        return q

    def move(self, cur, cmd, data):
        if cmd == CHAT_RET.NEXT:
            nxt = cur.next
            if nxt == None: # self.args[-1]:
                data.pop('pos')
                return CHAT_RET.NEXT
        else:
            nxt = cur

        self.setpos(data, nxt)
        return CHAT_RET.STAY

    def answer(self, resp, data):
        cur = self.getpos(data)
        debug_print(f'composite answer current {cur.key} data {data}')
        curdata = self.getdata(data, cur.key)

        if isinstance(cur, SkipSplitter):
            if cur.decider_fn(data) == 1:
                mov, ans = cur.answer(resp, data)
                return self.move(cur, mov, data), ans
            else:
                cur = cur.next
                self.setpos(data, cur)
                curdata = self.getdata(data, cur.key)

        if isinstance(cur, Splitter):
            mov, ans = cur.answer(resp, data)
        elif isinstance(cur, ComputeSegment):
            mov, ans = cur.answer(resp, data)
        else:
            mov, ans = cur.answer(resp, curdata)
        return self.move(cur, mov, data), ans


# Cell
class LoopComposite(Composite):
    """
    Composite element with ability to start from begin once end is reached.
    Should have a Skip element before to break loop
    """
    def move(self, cur, cmd, data):
        if cmd == CHAT_RET.NEXT:
            nxt = cur.next
            if nxt == None: # self.args[-1]:
                data.pop('pos')
                return CHAT_RET.STAY
        else:
            nxt = cur

        self.setpos(data, nxt)
        return CHAT_RET.STAY

# Cell
class TextAdapter(Pipe):
    """
    Text based adapter to invoke root element on user reponse.
    A similar adapter is needed for HTML or other bots
    """
    def __init__(self, root):
        super().__init__()
        self.root = root
        self.r = redis.Redis()

    def get_data(self, session):
        if self.r.exists(session):
            data = json.loads(self.r.get(session))
        else:
            data = {}
        return data

    def respond(self, inp, session):
        data = self.get_data(session)
        n, d1 = self.root.answer(inp, data)
#         if n == CHAT_RET.NEXT:
#             data.pop('pos')
        d2 = self.root.question(data)
        debug_print(f'adapter data {data}')
        self.r.set(session, json.dumps(data))
        d2_str = d2['txt']
        if 'choices' in d2:
            d2_str += '\n' + '\n'.join([f'{i+1}. {q}' for
                                        (i,q) in enumerate(d2['choices'])])
        return f"{d1['txt']}\n{d2_str}"

# Cell
class Splitter(Pipe):
    """
    Splitter element to branch flow based on some condition.
    """
    def __init__(self, key, *branches, decider_fn=lambda _: 0, default = 0):
        """
        branches are all possible branch elements (could be composites)
        decider_fn is passes data of parent and should return branch index
        (between 0 to n-1)
        default index is used if invalid index is returned by decider_fn
        """
        super().__init__()
        self.key = key
        self.branches = branches
        self.nodes = {}
        for a in branches:
            self.nodes[a.key] = a

        self.default = default
        self.decider_fn = decider_fn

    def decide(self, data):
        """
        Based on parent level data decide branch and return branch key
        """
        val = self.decider_fn(data)
        debug_print(f'decider {self.key} {val}')
        if val >= len(self.branches):
            val = self.default
        self.branches[val].next = self.next
        return self.branches[val].key

    def question(self, data):
        """
        Parent data for splitter
        """
        debug_print(f'splitter question data {data}')
        pos = self.decide(data)
        set_chained_data(data, self.key, 'pos', val = pos)
        debug_print(f'splitter question data after pos set {self.key} {pos} {data}')
        cur = self.nodes[pos]
        curdata = get_chained_data(data, self.key, cur.key)
        if curdata is None:
            curdata = {}
            set_chained_data(data, self.key, cur.key, val=curdata)
        return cur.question(curdata)

    def answer(self, resp, data):
        debug_print(f'splitter answer data {data}')
        pos = self.decide(data)
        set_chained_data(data, self.key, 'pos', val = pos)

        cur = self.nodes[pos]

        curdata = get_chained_data(data, self.key, cur.key)
        if curdata is None:
            curdata = {}
            set_chained_data(data, self.key, cur.key, val=curdata)

        mov, ans = cur.answer(resp, curdata)

        if mov == CHAT_RET.NEXT:
            return CHAT_RET.NEXT, ans

        return CHAT_RET.STAY, ans


# Cell
class SkipSplitter(Splitter):
    """
    A branch is taken on condition otherwise skips the branch
    (name taken from skipconnection in resnets)
    """
    def __init__(self, key, branch, decider_fn=lambda _: 0, default = 0):
        """
        Single branch should be passed
        if decide_fn returns 1, branch will be taken otherwise skipped
        """
        super().__init__(key, branch, decider_fn=decider_fn, default=default)

    def decide(self, data):
        """
        Based on parent level data decide if branch to be taken
        """
        val = self.decider_fn(data)
        return val

    def getpos(self, data):
        if (self.key in data) and  ('pos' in data[self.key]):
            return self.nodes[data[self.key]['pos']]

        data[self.key]['pos'] = self.branches[0].key
        return self.branches[0]

    def setpos(self, data, pos):
        data['pos'] = pos.key

    def getdata(self, data, key):
        if self.key in data:
            if key in data[self.key]:
                return data[self.key][key]
            else:
                data[self.key][key] = {}
                return data[self.key][key]
        data[self.key] = {}
        data[self.key][key] = {}
        return data[self.key][key]

    def question(self, data):
        """
        Parent data for splitter
        """
        debug_print(f'skip question data {data}')
        if self.decide(data) == 1:
            # take branch
            cur = self.getpos(data)
            curdata = self.getdata(data, cur.key)
            return cur.question(curdata)
        else:
            # skip branch
            data['pos'] = self.next.key
            return self.next.question({})

    def answer(self, resp, data):
        debug_print(f'skip answer data {data}')
        cur = self.getpos(data)
        curdata = self.getdata(data, cur.key)

        mov, ans = cur.answer(resp, curdata)

        if mov == CHAT_RET.NEXT:
            return CHAT_RET.NEXT, ans

        return CHAT_RET.STAY, ans
